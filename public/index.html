<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NTI XL2 Web Interface</title>
    <script src="/socket.io/socket.io.js"></script>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin=""/>
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
            crossorigin=""></script>
    <!-- Leaflet Heatmap Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px 0;
            text-align: center;
            margin-bottom: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #dc3545;
        }

        .status-dot.connected {
            background-color: #28a745;
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card h2 {
            color: #495057;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
        }

        .measurement-display {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin-bottom: 30px;
        }

        .measurement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .measurement-item {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .measurement-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .measurement-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .hz-12-5-highlight {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            border: 3px solid #fff;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: #007bff;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #0056b3;
        }

        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: #545b62;
        }

        .btn-success {
            background-color: #28a745;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background-color: #1e7e34;
        }

        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }

        .btn-warning:hover:not(:disabled) {
            background-color: #e0a800;
        }

        .btn-danger {
            background-color: #dc3545;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background-color: #c82333;
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .input, .select {
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            flex: 1;
        }

        .console {
            background: #212529;
            color: #ffffff;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            max-height: 400px;
            overflow-y: auto;
        }

        .console-message {
            margin-bottom: 5px;
            display: flex;
            gap: 10px;
        }

        .console-timestamp {
            color: #6c757d;
            flex-shrink: 0;
        }

        .console-direction {
            color: #ffc107;
            flex-shrink: 0;
            font-weight: bold;
            min-width: 30px;
        }

        .console-message.tx .console-direction {
            color: #fd7e14;
        }

        .console-message.rx .console-direction {
            color: #6f42c1;
        }

        .console-message.error .console-text {
            color: #dc3545;
        }

        .console-message.success .console-text {
            color: #28a745;
        }

        .hz-12-5-section {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
        }

        .hz-12-5-value {
            font-size: 3em;
            font-weight: bold;
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .hz-12-5-history {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .hz-12-5-history-item {
            background: rgba(255,255,255,0.2);
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            font-size: 0.9em;
        }

        .alert {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .alert-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .alert-warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .alert-danger {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .device-list-item {
            padding: 8px;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
        }

        .device-list-item:hover {
            background-color: #f8f9fa;
        }

        .device-list-item.xl2-device {
            background-color: #d4edda;
            font-weight: bold;
        }

        .device-list-item.xl2-device:hover {
            background-color: #c3e6cb;
        }

        .device-port {
            font-weight: bold;
            color: #495057;
        }

        .device-info {
            font-size: 0.9em;
            color: #6c757d;
            margin-top: 2px;
        }

        .device-manufacturer {
            font-size: 0.8em;
            color: #868e96;
        }

        #scanStatus {
            color: #6c757d;
            font-style: italic;
        }

        #scanStatus.scanning {
            color: #007bff;
        }

        #scanStatus.success {
            color: #28a745;
        }

        #scanStatus.error {
            color: #dc3545;
        }

        .fft-display {
            text-align: center;
            padding: 10px;
        }

        #fftCanvas {
            border: 1px solid #ddd;
            background-color: #000;
            width: 100%;
            max-width: 800px;
            height: 300px;
        }

        .fft-status {
            margin-top: 10px;
            font-style: italic;
            color: #6c757d;
        }

        .fft-status.active {
            color: #28a745;
        }

        .fft-hz-marker {
            position: absolute;
            background-color: #ff6b6b;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 15px;
            }
            
            .control-panel {
                grid-template-columns: 1fr;
            }
            
            .measurement-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
            
            .hz-12-5-value {
                font-size: 2em;
            }
            
            /* System performance mobile adjustments */
            .system-metrics {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 8px;
            }
            
            .system-metric {
                padding: 8px;
            }
            
            .system-metric-value {
                font-size: 1.1em;
            }
            
            .system-performance h3 {
                font-size: 1em;
            }
            
            .system-performance-toggle {
                padding: 3px 6px;
                font-size: 0.7em;
            }
        }

        /* GPS Map Styles */
        .gps-map-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .gps-map-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .gps-map-header h3 {
            color: #495057;
            margin: 0;
        }

        .map-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .map-controls button {
            padding: 5px 10px;
            font-size: 12px;
        }

        #gpsMap {
            height: 400px;
            width: 100%;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .gps-info-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .track-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .track-stat {
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .track-stat-value {
            font-weight: bold;
            font-size: 1.1em;
            color: #495057;
        }

        .track-stat-label {
            font-size: 0.8em;
            color: #6c757d;
            margin-top: 2px;
        }

        /* Heatmap Controls */
        .heatmap-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .heatmap-toggle {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
        }

        .heatmap-gradient {
            width: 100px;
            height: 15px;
            background: linear-gradient(to right, 
                rgba(0,0,255,0.8) 0%,     /* Blue - Low dB */
                rgba(0,255,255,0.8) 25%,  /* Cyan */
                rgba(0,255,0,0.8) 50%,    /* Green */
                rgba(255,255,0,0.8) 75%,  /* Yellow */
                rgba(255,0,0,0.8) 100%    /* Red - High dB */
            );
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        .db-measurement-marker {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #333;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        /* System Performance Styles */
        .system-performance {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .system-performance h3 {
            margin: 0 0 15px 0;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .system-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
        }

        .system-metric {
            background: rgba(255, 255, 255, 0.15);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .system-metric-value {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .system-metric-label {
            font-size: 0.8em;
            opacity: 0.9;
        }

        .system-metric.warning .system-metric-value {
            color: #ffc107;
        }

        .system-metric.danger .system-metric-value {
            color: #dc3545;
        }

        .system-performance.hidden {
            display: none;
        }

        .system-performance-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
        }

        .system-performance-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Pi 5 Enhanced Styling */
        .system-performance.pi5-enhanced {
            background: linear-gradient(135deg, #6f42c1 0%, #e83e8c 100%);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .system-performance.pi5-enhanced h3::after {
            content: " (Pi 5)";
            font-size: 0.8em;
            opacity: 0.8;
            font-weight: normal;
        }

        .system-performance.pi5-enhanced .system-metric {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .system-metric.critical .system-metric-value {
            color: #ff6b6b;
            animation: pulse-critical 2s infinite;
        }

        @keyframes pulse-critical {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ NTI XL2 Web Interface</h1>
            <p>USB Serial Connection ‚Ä¢ Real-time Measurements ‚Ä¢ 12.5Hz Focus</p>
        </div>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="connectionStatus"></div>
                <span id="connectionText">Disconnected</span>
            </div>
            <div id="deviceInfo">No device connected</div>
        </div>

        <!-- System Performance Monitor -->
        <div class="system-performance" id="systemPerformance">
            <button class="system-performance-toggle" onclick="toggleSystemPerformance()" title="Hide/Show System Performance">‚àí</button>
            <h3>‚ö° System Performance</h3>
            <div class="system-metrics">
                <div class="system-metric">
                    <div class="system-metric-value" id="cpuTemp">--¬∞C</div>
                    <div class="system-metric-label">CPU Temp</div>
                </div>
                <div class="system-metric">
                    <div class="system-metric-value" id="memoryUsage">--%</div>
                    <div class="system-metric-label">Memory</div>
                </div>
                <div class="system-metric">
                    <div class="system-metric-value" id="diskSpace">--GB</div>
                    <div class="system-metric-label">Free Space</div>
                </div>
                <div class="system-metric">
                    <div class="system-metric-value" id="uptime">--</div>
                    <div class="system-metric-label">Uptime</div>
                </div>
                <div class="system-metric">
                    <div class="system-metric-value" id="connectedClients">0</div>
                    <div class="system-metric-label">Clients</div>
                </div>
                <div class="system-metric">
                    <div class="system-metric-value" id="systemLoad">--%</div>
                    <div class="system-metric-label">CPU Load</div>
                </div>
            </div>
        </div>

        <!-- 12.5Hz Special Display -->
        <div class="hz-12-5-section">
            <h2>üéØ 12.5Hz Measurement</h2>
            <div class="hz-12-5-value" id="hz12_5Value">-- dB</div>
            <div>Last updated: <span id="hz12_5Timestamp">Never</span></div>
            <div class="hz-12-5-history" id="hz12_5History"></div>
        </div>

        <!-- Current Measurement Display -->
        <div class="measurement-display" id="measurementDisplay">
            <h2>üìä Current Measurement</h2>
            <div class="measurement-grid">
                <div class="measurement-item">
                    <div class="measurement-value" id="frequencyValue">12.5</div>
                    <div class="measurement-label">Frequency (Hz)</div>
                </div>
                <div class="measurement-item">
                    <div class="measurement-value" id="dbValue">--</div>
                    <div class="measurement-label">Level (dB)</div>
                </div>
            </div></div>

            <!-- FFT Info -->
            <div class="card">
                <h2>üìä FFT Info</h2>
                <div id="fftInfo" class="device-info">
                    <div>Frequency bins: <span id="fftBinCount">--</span></div>
                    <div>Frequency range: <span id="fftRange">--</span></div>
                    <div>12.5Hz bin: <span id="fft12_5Bin">--</span></div>
                    <div>12.5Hz frequency: <span id="fft12_5Freq">--</span></div>
                    <div>Update rate: <span id="fftUpdateRate">--</span></div>
                </div>
            </div>

            <!-- Live FFT Display -->
            <div class="card">
                <h2>üìà Live FFT Spectrum</h2>
                <div id="fftDisplay" class="fft-display">
                    <canvas id="fftCanvas" width="800" height="300"></canvas>
                    <div id="fftStatus" class="fft-status">Waiting for FFT data...</div>
                </div>
            </div>

            <!-- GPS Status -->
            <div class="card">
                <h2>üõ∞Ô∏è GPS Status</h2>
                <div id="gpsInfo" class="device-info">
                    <div>Status: <span id="gpsStatus">Not connected</span></div>
                    <div>Latitude: <span id="gpsLat">--</span></div>
                    <div>Longitude: <span id="gpsLon">--</span></div>
                    <div>Altitude: <span id="gpsAlt">--</span> m</div>
                    <div>Satellites: <span id="gpsSats">--</span></div>
                    <div>Fix Quality: <span id="gpsFix">--</span></div>
                </div>
            </div>

            <!-- GPS Live Map -->
            <div class="gps-map-container">
                <div class="gps-map-header">
                    <h3>üó∫Ô∏è Live GPS Tracking</h3>
                    <div class="map-controls">
                        <button onclick="centerMapOnGPS()" class="btn btn-primary" id="centerMapBtn" disabled>üìç Center on GPS</button>
                        <button onclick="clearTrack()" class="btn btn-warning" id="clearTrackBtn">üóëÔ∏è Clear Track</button>
                        <button onclick="toggleTracking()" class="btn btn-success" id="trackingBtn">‚ñ∂Ô∏è Start Tracking</button>
                        <button onclick="toggleHeatmap()" class="btn btn-secondary" id="heatmapBtn">üî• Show Heatmap</button>
                        <button onclick="recalculateHeatmapData()" class="btn btn-info" id="recalcHeatmapBtn">üîÑ Recalc Range</button>
                        <button onclick="testHeatmap()" class="btn btn-warning" id="testHeatmapBtn">üß™ Test Heatmap</button>
                        <button onclick="clearHeatmap()" class="btn btn-warning" id="clearHeatmapBtn">üóëÔ∏è Clear dB Data</button>
                        <button onclick="loadCSVData()" class="btn btn-info" id="loadCSVBtn">üìä Load CSV Data</button>
                    </div>
                </div>
                <div id="gpsMap"></div>
                
                <!-- Heatmap Controls -->
                <div class="heatmap-controls">
                    <div class="heatmap-toggle">
                        <input type="checkbox" id="heatmapToggle" onchange="toggleHeatmapVisibility()">
                        <label for="heatmapToggle">Show 12.5Hz dB Heatmap</label>
                    </div>
                    <div class="heatmap-legend">
                        <span>Low dB</span>
                        <div class="heatmap-gradient"></div>
                        <span>High dB</span>
                        <span id="heatmapRange">Range: -- to -- dB</span>
                    </div>
                    <div>
                        <span>Points: <strong id="heatmapPoints">0</strong></span>
                    </div>
                </div>
                
                <div class="track-stats">
                    <div class="track-stat">
                        <div class="track-stat-value" id="trackDistance">0.0</div>
                        <div class="track-stat-label">Distance (m)</div>
                    </div>
                    <div class="track-stat">
                        <div class="track-stat-value" id="trackPoints">0</div>
                        <div class="track-stat-label">Track Points</div>
                    </div>
                    <div class="track-stat">
                        <div class="track-stat-value" id="currentSpeed">0.0</div>
                        <div class="track-stat-label">Speed (km/h)</div>
                    </div>
                    <div class="track-stat">
                        <div class="track-stat-value" id="maxSpeed">0.0</div>
                        <div class="track-stat-label">Max Speed (km/h)</div>
                    </div>
                </div>
            </div>

            <!-- Logging Status -->
            <div class="card">
                <h2>üìù CSV Logging</h2>
                <div id="loggingInfo" class="device-info">
                    <div>Status: <span id="loggingStatus">Stopped</span></div>
                    <div>File: <span id="loggingFile">--</span></div>
                    <div>Started: <span id="loggingStartTime">--</span></div>
                    <div>Records: <span id="loggingRecords">--</span></div>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <!-- Connection Control -->
            <div class="card">
                <h2>üîå Connection</h2>
                
                <!-- Status Refresh -->
                <div class="input-group">
                    <button onclick="refreshStatus()" class="btn btn-info">üîÑ Refresh Status</button>
                    <button onclick="scanForDevices()" id="scanBtn" class="btn btn-warning">üîç Scan All COM Ports</button>
                    <span id="scanStatus" style="margin-left: 10px; font-style: italic;"></span>
                </div>
                
                <!-- Device Selection -->
                <div class="input-group">
                    <label for="deviceSelect" style="display: block; margin-bottom: 5px; font-weight: bold;">üì± Found XL2 Devices:</label>
                    <select id="deviceSelect" class="select" size="3" style="height: 80px;">
                        <option value="">Click "Scan All COM Ports" to find XL2 devices</option>
                    </select>
                </div>
                
                <!-- Manual Port Selection (fallback) -->
                <div class="input-group" style="margin-top: 15px;">
                    <label for="portSelect" style="display: block; margin-bottom: 5px; font-weight: bold;">üîß Manual Port Selection (if scan fails):</label>
                    <div style="display: flex; gap: 10px;">
                        <select id="portSelect" class="select" style="flex: 1;">
                            <option value="">Select COM port manually...</option>
                        </select>
                        <button onclick="refreshPorts()" class="btn btn-secondary">Refresh</button>
                    </div>
                </div>
                
                <div class="button-group">
                    <button onclick="connect()" id="connectBtn" class="btn btn-primary">Connect Selected</button>
                    <button onclick="disconnect()" id="disconnectBtn" class="btn btn-secondary" disabled>Disconnect</button>
                </div>
                
                <!-- Connection Status -->
                <div class="alert alert-info" style="margin-top: 15px;">
                    <strong>üîå Status:</strong> <span id="connectionStatus">Not connected</span>
                </div>
            </div>

            <!-- Quick Commands -->
            <div class="card">
                <h2>‚ö° Quick Commands</h2>
                <div class="button-group">
                    <button onclick="sendCommand('*IDN?')" class="btn btn-success">Device Info</button>
                    <button onclick="initializeFFT()" class="btn btn-warning">üîß Re-init FFT</button>
                    <button onclick="getDeviceStatus()" class="btn btn-success">Status</button>
                    <button onclick="sendCommand('*RST')" class="btn btn-secondary">Reset</button>
                </div>
                <div class="alert alert-info" style="margin-top: 10px; font-size: 0.9em;">
                    ‚ÑπÔ∏è FFT measurements start automatically on connection
                </div>
            </div>

            <!-- FFT Control -->
            <div class="card">
                <h2>üìä FFT Control</h2>
                <div class="button-group">
                    <button onclick="getFFTFrequencies()" class="btn btn-primary">Get Frequencies</button>
                    <button onclick="getFFTSpectrum()" class="btn btn-primary">Get Spectrum</button>
                    <button onclick="setFrequency(12.5)" class="btn btn-warning">Set 12.5 Hz Context</button>
                    <button onclick="drawTestSpectrum()" class="btn btn-secondary">Test Canvas</button>
                    <button onclick="forceCanvasTest()" class="btn btn-info">Force Canvas Test</button>
                </div>
                <div class="input-group">
                    <input type="number" id="zoomInput" placeholder="9" class="input" min="0" max="15">
                    <button onclick="setFFTZoom()" class="btn btn-secondary">Set Zoom</button>
                </div>
                <div class="input-group">
                    <input type="number" id="fstartInput" placeholder="12.5" class="input" min="0" step="0.1">
                    <button onclick="setFFTStart()" class="btn btn-secondary">Set F Start</button>
                </div>
                <div class="alert alert-info" style="margin-top: 10px; font-size: 0.9em;">
                    ‚ÑπÔ∏è Default FSTART = 12.5 Hz (first bin = 12.5Hz exactly)<br>
                    üîÑ Frequencies auto-retrieved after zoom/fstart changes
                </div>
            </div>

            <!-- Measurement Control -->
            <div class="card">
                <h2>üìà Live FFT Control</h2>
                <div class="button-group">
                    <button onclick="startContinuousFFT()" id="startFFTBtn" class="btn btn-success">‚ñ∂Ô∏è Start Live FFT</button>
                    <button onclick="stopContinuousFFT()" id="stopFFTBtn" class="btn btn-warning">‚èπÔ∏è Stop Live FFT</button>
                    <button onclick="triggerMeasurement()" class="btn btn-primary">üîÑ Manual Trigger</button>
                </div>
                <div class="alert alert-info" style="margin-top: 10px; font-size: 0.9em;">
                    ‚ÑπÔ∏è Live FFT triggers new measurements every 1.5 seconds
                </div>
            </div>

            <!-- GPS Control -->
            <div class="card">
                <h2>üõ∞Ô∏è GPS Control</h2>
                <div class="input-group">
                    <button onclick="scanGPS()" id="gpsScanBtn" class="btn btn-warning">üîç Scan GPS Ports</button>
                    <span id="gpsScanStatus" style="margin-left: 10px; font-style: italic;"></span>
                </div>
                
                <div class="input-group">
                    <label for="gpsSelect" style="display: block; margin-bottom: 5px; font-weight: bold;">üì° GPS Ports:</label>
                    <select id="gpsSelect" class="select" size="2" style="height: 60px;">
                        <option value="">Click "Scan GPS Ports" to find VK-162</option>
                    </select>
                </div>
                
                <div class="button-group">
                    <button onclick="connectGPS()" id="gpsConnectBtn" class="btn btn-primary">Connect GPS</button>
                    <button onclick="disconnectGPS()" id="gpsDisconnectBtn" class="btn btn-secondary" disabled>Disconnect GPS</button>
                </div>
            </div>

            <!-- Logging Control -->
            <div class="card">
                <h2>üìù CSV Logging Control</h2>
                <div class="button-group">
                    <button onclick="startLogging()" id="startLogBtn" class="btn btn-success">‚ñ∂Ô∏è Start Logging</button>
                    <button onclick="stopLogging()" id="stopLogBtn" class="btn btn-warning" disabled>‚èπÔ∏è Stop Logging</button>
                </div>
                <div class="alert alert-info" style="margin-top: 10px; font-size: 0.9em;">
                    üìä Logs: Datum, Uhrzeit, 12.5Hz Pegel, GPS Koordinaten<br>
                    üìÅ Files saved to: <code>logs/Log_YYYY-MM-DD-HH-mm-ss.csv</code>
                </div>
            </div>

            <!-- Custom Command -->
            <div class="card">
                <h2>‚å®Ô∏è Custom Command</h2>
                <div class="input-group">
                    <input type="text" id="customCommand" placeholder="Enter command..." class="input">
                    <button onclick="sendCustomCommand()" class="btn btn-primary">Send</button>
                </div>
            </div>
        </div>

        <!-- Console -->
        <div class="card">
            <h2>üñ•Ô∏è Console</h2>
            <div class="console" id="console"></div>
            <button onclick="clearConsole()" class="btn btn-secondary" style="margin-top: 10px;">Clear Console</button>
        </div>
    </div>

    <script>
        console.log('üîß JavaScript loading...');
        
        // WebSocket connection
        const socket = io();
        let isConnected = false;
        
        // Socket connection debugging
        socket.on('connect', () => {
            console.log('üîå Socket connected:', socket.id);
            addConsoleMessage('üîå Socket connected to server', 'success');
        });
        
        socket.on('disconnect', () => {
            console.log('üîå Socket disconnected');
            addConsoleMessage('üîå Socket disconnected from server', 'warning');
        });
        
        socket.on('connect_error', (error) => {
            console.error('üîå Socket connection error:', error);
            addConsoleMessage('üîå Socket connection error: ' + error.message, 'error');
        });
        let isContinuous = false;
        let hz12_5History = [];
        let fftCanvas = null;
        let fftCtx = null;
        let fftFrequencies = null;
        let lastFFTUpdate = null;

        // GPS Map variables
        let gpsMap = null;
        let gpsMarker = null;
        let gpsTrack = [];
        let gpsTrackLine = null;
        let isTracking = false;
        let totalDistance = 0;
        let maxSpeed = 0;
        let lastGPSPosition = null;

        // Heatmap variables
        let heatmapLayer = null;
        let heatmapData = [];
        let dbMeasurements = [];
        let isHeatmapVisible = false;
        let minDb = null;
        let maxDb = null;

        // DOM elements - will be initialized after DOM loads
        let connectionStatus = null;
        let connectionText = null;
        let deviceInfo = null;
        let consoleElement = null;
        let portSelect = null;
        let connectBtn = null;
        let disconnectBtn = null;
        let continuousBtn = null;
        let stopBtn = null;

        // Socket event handlers
        socket.on('connect', () => {
            addConsoleMessage('Connected to server', 'success');
           
            
            // DISABLED: Don't request status on connect to avoid interfering with measurements
            // Server automatically sends current state to new clients
            // setTimeout(() => {
            //     console.log('üîÑ Requesting current status from server...');
            //     socket.emit('request-current-status');
            // }, 200);
        });

        socket.on('xl2-connected', (port) => {
            isConnected = true;
            updateConnectionStatus(true, `Connected to ${port}`);
            
            // Reset and update button states
            const connectBtn = document.getElementById('connectBtn');
            connectBtn.disabled = true;
            connectBtn.textContent = 'Connect Selected'; // Reset text
            disconnectBtn.disabled = false;
            
            addConsoleMessage(`XL2 connected on ${port}`, 'success');
            addConsoleMessage(`üîÑ Auto-starting FFT measurements...`, 'info');
            
            // Update FFT status and button states
            document.getElementById('fftStatus').textContent = 'Initializing FFT...';
            document.getElementById('fftStatus').className = 'fft-status';
            document.getElementById('startFFTBtn').disabled = true; // Will be enabled after auto-start
            document.getElementById('stopFFTBtn').disabled = false;
        });

        socket.on('xl2-disconnected', () => {
            isConnected = false;
            updateConnectionStatus(false, 'Disconnected');
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            continuousBtn.disabled = false;
            stopBtn.disabled = true;
            isContinuous = false;
            addConsoleMessage('XL2 disconnected', 'info');
            
            // Clear FFT display
            if (fftCtx) {
                fftCtx.fillStyle = '#000';
                fftCtx.fillRect(0, 0, fftCanvas.width, fftCanvas.height);
            }
            document.getElementById('fftStatus').textContent = 'Disconnected';
            document.getElementById('fftStatus').className = 'fft-status';
            
            // Clear FFT info
            document.getElementById('fftBinCount').textContent = '--';
            document.getElementById('fftRange').textContent = '--';
            document.getElementById('fft12_5Bin').textContent = '--';
            document.getElementById('fft12_5Freq').textContent = '--';
            document.getElementById('fftUpdateRate').textContent = '--';
            
            // Reset button states
            document.getElementById('startFFTBtn').disabled = false;
            document.getElementById('stopFFTBtn').disabled = true;
        });

        socket.on('xl2-data', (data) => {
            addConsoleMessage(data, 'rx', 'RX:');
        });

        socket.on('xl2-command', (command) => {
            addConsoleMessage(command, 'tx', 'TX:');
        });

        socket.on('xl2-measurement', (measurement) => {
            updateMeasurementDisplay(measurement);
            
            // Special handling for 12.5Hz
            if (measurement.is12_5Hz) {
                update12_5HzDisplay(measurement);
                
                // Add to heatmap if GPS position is available and we have dB value
                if (lastGPSPosition && lastGPSPosition.latitude && lastGPSPosition.longitude && measurement.dB) {
                    addDbMeasurement(lastGPSPosition.latitude, lastGPSPosition.longitude, measurement.dB);
                }
            }
        });

        socket.on('xl2-device-info', (info) => {
            deviceInfo.textContent = info;
            addConsoleMessage(`Device: ${info}`, 'success');
        });

        socket.on('xl2-measurement-started', () => {
            addConsoleMessage('XL2 measurement started', 'success');
        });

        socket.on('xl2-measurement-stopped', () => {
            addConsoleMessage('XL2 measurement stopped', 'info');
        });

        socket.on('xl2-continuous-started', () => {
            addConsoleMessage('Continuous measurement started', 'success');
            continuousBtn.disabled = true;
            stopBtn.disabled = false;
            isContinuous = true;
        });

        socket.on('xl2-frequency-set', (frequency) => {
            addConsoleMessage(`Frequency context set to ${frequency} Hz`, 'success');
        });

        socket.on('xl2-fft-initialized', () => {
            addConsoleMessage('FFT mode initialized successfully', 'success');
        });

        socket.on('xl2-fft-frequencies', (data) => {
            if (data.frequencies) {
                fftFrequencies = data.frequencies; // Store for visualization
                
                addConsoleMessage(`FFT frequencies: ${data.frequencies.length} bins (${data.frequencies[0]} - ${data.frequencies[data.frequencies.length-1]} Hz)`, 'success');
                if (data.hz12_5_frequency) {
                    addConsoleMessage(`üéØ 12.5Hz closest bin: ${data.hz12_5_frequency} Hz (index ${data.hz12_5_index})`, 'success');
                }
                
                // Update FFT info display
                document.getElementById('fftBinCount').textContent = data.frequencies.length;
                document.getElementById('fftRange').textContent = `${data.frequencies[0]} - ${data.frequencies[data.frequencies.length-1]} Hz`;
                document.getElementById('fft12_5Bin').textContent = data.hz12_5_index >= 0 ? data.hz12_5_index : '--';
                document.getElementById('fft12_5Freq').textContent = data.hz12_5_frequency ? `${data.hz12_5_frequency} Hz` : '--';
                
                console.log('FFT Frequencies:', data);
            }
        });

        // Test event handler
        socket.on('test-event', (data) => {
            console.log('üß™ TEST EVENT RECEIVED:', data);
            addConsoleMessage(`üß™ Test: ${data.message}`, 'info');
        });

        socket.on('xl2-fft-spectrum', (data) => {
            console.log('üéØ Received xl2-fft-spectrum:', data);
            
            if (data.spectrum) {
                lastFFTUpdate = new Date();
                
                console.log('üìä Spectrum data:', {
                    length: data.spectrum.length,
                    first5: data.spectrum.slice(0, 5),
                    hz12_5_value: data.hz12_5_value,
                    hz12_5_index: data.hz12_5_index,
                    canvasReady: !!fftCanvas && !!fftCtx,
                    frequenciesReady: !!fftFrequencies
                });
                
                // Update console (less verbose for live updates)
                if (data.hz12_5_value !== null) {
                    addConsoleMessage(`üéØ 12.5Hz: ${data.hz12_5_value.toFixed(2)} dB at ${data.hz12_5_frequency} Hz`, 'success');
                    
                    // Add to heatmap if GPS position is available
                    if (lastGPSPosition && lastGPSPosition.latitude && lastGPSPosition.longitude) {
                        addDbMeasurement(lastGPSPosition.latitude, lastGPSPosition.longitude, data.hz12_5_value);
                        
                        // Auto-enable heatmap if this is the first measurement and heatmap is not visible
                        if (dbMeasurements.length === 1 && !isHeatmapVisible) {
                            if (!heatmapLayer) {
                                initializeHeatmap();
                            }
                            if (heatmapLayer) {
                                try {
                                    gpsMap.addLayer(heatmapLayer);
                                    heatmapLayer.setLatLngs(heatmapData);
                                    isHeatmapVisible = true;
                                    
                                    const btn = document.getElementById('heatmapBtn');
                                    const checkbox = document.getElementById('heatmapToggle');
                                    if (btn) {
                                        btn.textContent = 'üî• Hide Heatmap';
                                        btn.className = 'btn btn-primary';
                                    }
                                    if (checkbox) checkbox.checked = true;
                                    
                                    addConsoleMessage('üî• Heatmap automatically enabled for live measurements', 'info');
                                } catch (error) {
                                    console.error('üî• Error auto-enabling heatmap:', error);
                                }
                            }
                        }
                    }
                }
                
                // Update FFT visualization
                console.log('üé® About to draw spectrum with frequencies:', !!fftFrequencies, 'canvas ready:', !!fftCanvas && !!fftCtx);
                console.log('üé® Spectrum data sample:', data.spectrum.slice(0, 5));
                
                // Force canvas test
                if (!fftCanvas || !fftCtx) {
                    console.warn('üîß Canvas not ready, initializing...');
                    initFFTCanvas();
                }
                
                // Test draw a simple rectangle to verify canvas works
                if (fftCtx) {
                    fftCtx.fillStyle = 'red';
                    fftCtx.fillRect(10, 10, 50, 50);
                    console.log('üî¥ Test red rectangle drawn');
                }
                
                drawFFTSpectrum(data.spectrum, fftFrequencies, data.hz12_5_index);
                
                // Update rate display
                document.getElementById('fftUpdateRate').textContent = '~0.67 Hz (live)';
                
                console.log('‚úÖ FFT Spectrum processed');
            } else {
                console.warn('‚ùå No spectrum data in xl2-fft-spectrum event');
            }
        });

        socket.on('xl2-continuous-fft-started', () => {
            addConsoleMessage('üîÑ Continuous FFT measurements started', 'success');
            document.getElementById('startFFTBtn').disabled = true;
            document.getElementById('stopFFTBtn').disabled = false;
            document.getElementById('fftStatus').textContent = 'Live FFT Running...';
            document.getElementById('fftStatus').className = 'fft-status active';
        });

        socket.on('xl2-continuous-fft-stopped', () => {
            addConsoleMessage('‚èπÔ∏è Continuous FFT measurements stopped', 'info');
            document.getElementById('startFFTBtn').disabled = false;
            document.getElementById('stopFFTBtn').disabled = true;
            document.getElementById('fftStatus').textContent = 'FFT Stopped';
            document.getElementById('fftStatus').className = 'fft-status';
        });

        socket.on('xl2-command-success', (message) => {
            addConsoleMessage(`‚úÖ ${message}`, 'success');
        });

        // GPS Event Handlers
        socket.on('gps-ports', (ports) => {
            const gpsSelect = document.getElementById('gpsSelect');
            gpsSelect.innerHTML = '<option value="">Select GPS port...</option>';
            
            ports.forEach(port => {
                const option = document.createElement('option');
                option.value = port.path;
                option.textContent = `${port.path} - ${port.manufacturer || 'Unknown'} (${port.vendorId || 'N/A'})`;
                gpsSelect.appendChild(option);
            });
            
            addConsoleMessage(`üõ∞Ô∏è Found ${ports.length} potential GPS ports`, 'success');
        });

        socket.on('gps-connected', (port) => {
            addConsoleMessage(`üõ∞Ô∏è GPS connected on ${port}`, 'success');
            
            // Update GPS connection buttons
            const gpsConnectBtn = document.getElementById('gpsConnectBtn');
            const gpsDisconnectBtn = document.getElementById('gpsDisconnectBtn');
            if (gpsConnectBtn) gpsConnectBtn.disabled = true;
            if (gpsDisconnectBtn) gpsDisconnectBtn.disabled = false;
            
            // Update GPS status display
            const gpsStatus = document.getElementById('gpsStatus');
            if (gpsStatus) {
                gpsStatus.textContent = `Connected (${port})`;
                gpsStatus.style.color = '#28a745';
                gpsStatus.style.fontWeight = 'bold';
            }
            
            // Enable map controls
            const centerMapBtn = document.getElementById('centerMapBtn');
            if (centerMapBtn) centerMapBtn.disabled = false;
            
            console.log(`üõ∞Ô∏è GPS status updated: Connected to ${port}`);
        });

        socket.on('gps-disconnected', () => {
            addConsoleMessage('üõ∞Ô∏è GPS disconnected', 'info');
            
            // Update GPS connection buttons
            const gpsConnectBtn = document.getElementById('gpsConnectBtn');
            const gpsDisconnectBtn = document.getElementById('gpsDisconnectBtn');
            if (gpsConnectBtn) gpsConnectBtn.disabled = false;
            if (gpsDisconnectBtn) gpsDisconnectBtn.disabled = true;
            
            // Update GPS status display
            const gpsStatus = document.getElementById('gpsStatus');
            if (gpsStatus) {
                gpsStatus.textContent = 'Not connected';
                gpsStatus.style.color = '#dc3545';
                gpsStatus.style.fontWeight = 'normal';
            }
            
            // Clear GPS data
            const elements = ['gpsLat', 'gpsLon', 'gpsAlt', 'gpsSats', 'gpsFix'];
            elements.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.textContent = '--';
            });
            
            // Disable map controls and clear marker
            const centerMapBtn = document.getElementById('centerMapBtn');
            if (centerMapBtn) centerMapBtn.disabled = true;
            if (gpsMarker) {
                gpsMap.removeLayer(gpsMarker);
                gpsMarker = null;
            }
            
            console.log('üõ∞Ô∏è GPS status updated: Disconnected');
        });

        socket.on('gps-update', (location) => {
            document.getElementById('gpsLat').textContent = location.latitude ? location.latitude.toFixed(6) : '--';
            document.getElementById('gpsLon').textContent = location.longitude ? location.longitude.toFixed(6) : '--';
            document.getElementById('gpsAlt').textContent = location.altitude ? location.altitude.toFixed(1) : '--';
            document.getElementById('gpsSats').textContent = location.satellites || '--';
            document.getElementById('gpsFix').textContent = location.fix || '--';
            
            // Update GPS map
            updateGPSMap(location);
        });

        socket.on('gps-error', (error) => {
            addConsoleMessage(`üõ∞Ô∏è GPS Error: ${error}`, 'error');
        });

        // Logging Event Handlers
        socket.on('logging-started', (info) => {
            addConsoleMessage(`üìù Logging started: ${info.filePath}`, 'success');
            document.getElementById('startLogBtn').disabled = true;
            document.getElementById('stopLogBtn').disabled = false;
            document.getElementById('loggingStatus').textContent = 'Active';
            document.getElementById('loggingStatus').style.color = '#28a745';
            document.getElementById('loggingFile').textContent = info.filePath.split('/').pop();
            document.getElementById('loggingStartTime').textContent = new Date(info.startTime).toLocaleString('de-DE');
        });

        socket.on('logging-stopped', (info) => {
            addConsoleMessage(`üìù Logging stopped. File saved: ${info.filePath}`, 'success');
            document.getElementById('startLogBtn').disabled = false;
            document.getElementById('stopLogBtn').disabled = true;
            document.getElementById('loggingStatus').textContent = 'Stopped';
            document.getElementById('loggingStatus').style.color = '#dc3545';
        });

        socket.on('logging-error', (error) => {
            addConsoleMessage(`üìù Logging Error: ${error}`, 'error');
        });

        socket.on('xl2-error', (error) => {
            addConsoleMessage(`Error: ${error}`, 'error');
            
            // Reset connection button on error
            const connectBtn = document.getElementById('connectBtn');
            connectBtn.disabled = false;
            connectBtn.textContent = 'Connect Selected';
            updateConnectionStatus(false, 'Connection failed');
        });

        socket.on('xl2-ports', (ports) => {
            updatePortList(ports);
        });

        socket.on('xl2-scan-status', (status) => {
            updateScanStatus(status, 'scanning');
        });

        socket.on('xl2-devices-found', (devices) => {
            updateDeviceList(devices);
            const xl2Count = devices.filter(d => d.isXL2).length;
            updateScanStatus(`Found ${xl2Count} XL2 device(s) out of ${devices.length} ports scanned`, 'success');
        });

        // Connection functions
        function connect() {
            const deviceSelect = document.getElementById('deviceSelect');
            const portSelect = document.getElementById('portSelect');
            const connectBtn = document.getElementById('connectBtn');
            
            let selectedPort = null;
            
            // Check if a device is selected from the scan results
            if (deviceSelect.value) {
                selectedPort = deviceSelect.value;
                addConsoleMessage(`Connecting to scanned XL2: ${selectedPort}`, 'info');
            } else if (portSelect.value) {
                // Fallback to manual port selection
                selectedPort = portSelect.value;
                addConsoleMessage(`Connecting to manual port: ${selectedPort}`, 'info');
            }
            
            if (selectedPort) {
                // Update UI state
                connectBtn.disabled = true;
                connectBtn.textContent = 'Connecting...';
                updateConnectionStatus(false, 'Connecting...');
                
                // Clear previous FFT data
                if (fftCtx) {
                    fftCtx.fillStyle = '#000';
                    fftCtx.fillRect(0, 0, fftCanvas.width, fftCanvas.height);
                }
                document.getElementById('fftStatus').textContent = 'Connecting...';
                
                socket.emit('xl2-connect', selectedPort);
            } else {
                addConsoleMessage('Please select a device or scan for devices first', 'error');
            }
        }

        function disconnect() {
            socket.emit('xl2-disconnect');
        }

        function refreshPorts() {
            socket.emit('xl2-list-ports');
        }

        function refreshStatus() {
            // DISABLED: Server automatically manages status updates
            // Manual status requests could interfere with ongoing measurements
            addConsoleMessage('üîÑ Server manages status automatically - no manual refresh needed', 'info');
            // socket.emit('request-current-status');
        }

        function scanForDevices() {
            const scanBtn = document.getElementById('scanBtn');
            const deviceSelect = document.getElementById('deviceSelect');
            
            scanBtn.disabled = true;
            scanBtn.textContent = 'üîç Scanning...';
            deviceSelect.innerHTML = '<option>Scanning all COM ports...</option>';
            
            socket.emit('xl2-scan-devices');
            
            // Re-enable button after scan
            setTimeout(() => {
                scanBtn.disabled = false;
                scanBtn.textContent = 'üîç Scan All COM Ports';
            }, 10000); // 10 second timeout
        }

        // Command functions
        function sendCommand(command) {
            if (!isConnected) {
                addConsoleMessage('Not connected to XL2', 'error');
                return;
            }
            socket.emit('xl2-send-command', command);
        }

        function sendCustomCommand() {
            const command = document.getElementById('customCommand').value.trim();
            if (command) {
                sendCommand(command);
                document.getElementById('customCommand').value = '';
            }
        }

        // GPS Functions
        function scanGPS() {
            addConsoleMessage('üõ∞Ô∏è Scanning for GPS devices...', 'info');
            socket.emit('gps-scan');
        }

        function connectGPS() {
            const gpsSelect = document.getElementById('gpsSelect');
            if (gpsSelect.value) {
                addConsoleMessage(`Connecting to GPS: ${gpsSelect.value}`, 'info');
                socket.emit('gps-connect', gpsSelect.value);
            } else {
                addConsoleMessage('Please select a GPS port first', 'error');
            }
        }

        function disconnectGPS() {
            socket.emit('gps-disconnect');
        }

        // Logging Functions
        function startLogging() {
            addConsoleMessage('üìù Starting CSV logging...', 'info');
            socket.emit('logging-start');
        }

        function stopLogging() {
            addConsoleMessage('üìù Stopping CSV logging...', 'info');
            socket.emit('logging-stop');
        }

        function setFrequency(freq = null) {
            const frequency = freq || document.getElementById('frequencyInput').value;
            if (frequency) {
                socket.emit('xl2-set-frequency', parseFloat(frequency));
            }
        }

        function singleMeasurement() {
            socket.emit('xl2-single-measurement');
        }

        function initializeFFT() {
            socket.emit('xl2-initialize-fft');
        }

        function getFFTFrequencies() {
            socket.emit('xl2-get-fft-frequencies');
        }

        function getFFTSpectrum() {
            socket.emit('xl2-get-fft-spectrum');
        }

        function setFFTZoom() {
            const zoom = document.getElementById('zoomInput').value;
            if (zoom) {
                addConsoleMessage(`Setting FFT zoom to ${zoom}...`, 'info');
                socket.emit('xl2-set-fft-zoom', parseInt(zoom));
            } else {
                addConsoleMessage('Please enter a zoom value (0-15)', 'error');
            }
        }

        function setFFTStart() {
            const fstart = document.getElementById('fstartInput').value;
            if (fstart) {
                addConsoleMessage(`Setting FFT start frequency to ${fstart} Hz...`, 'info');
                socket.emit('xl2-set-fft-start', parseFloat(fstart));
            } else {
                addConsoleMessage('Please enter a start frequency', 'error');
            }
        }

        function triggerMeasurement() {
            socket.emit('xl2-trigger-measurement');
        }

        function stopMeasurement() {
            socket.emit('xl2-stop-measurement');
        }

        function startContinuousFFT() {
            socket.emit('xl2-start-continuous-fft');
            document.getElementById('startFFTBtn').disabled = true;
            document.getElementById('stopFFTBtn').disabled = false;
        }

        function stopContinuousFFT() {
            socket.emit('xl2-stop-continuous-fft');
            document.getElementById('startFFTBtn').disabled = false;
            document.getElementById('stopFFTBtn').disabled = true;
        }

        function getDeviceStatus() {
            socket.emit('xl2-device-status');
        }

        // Display update functions
        function updateConnectionStatus(connected, text) {
            const connectionStatus = document.getElementById('connectionStatus');
            const connectionText = document.getElementById('connectionText');
            const deviceInfo = document.getElementById('deviceInfo');
            
            if (connectionStatus) {
                connectionStatus.classList.toggle('connected', connected);
            }
            
            if (connectionText) {
                connectionText.textContent = text;
            }
            
            if (deviceInfo) {
                deviceInfo.textContent = connected ? text : 'No device connected';
            }
            
            console.log(`üîÑ Connection status updated: ${connected ? 'Connected' : 'Disconnected'} - ${text}`);
        }

        function updatePortList(ports) {
            portSelect.innerHTML = '<option value="">Manual port selection (if scan fails)</option>';
            ports.forEach(port => {
                const option = document.createElement('option');
                option.value = port.path;
                option.textContent = `${port.path} - ${port.manufacturer || 'Unknown'}`;
                portSelect.appendChild(option);
            });
        }

        function updateDeviceList(devices) {
            const deviceSelect = document.getElementById('deviceSelect');
            deviceSelect.innerHTML = '';
            
            if (devices.length === 0) {
                const option = document.createElement('option');
                option.textContent = 'No devices found';
                option.disabled = true;
                deviceSelect.appendChild(option);
                return;
            }
            
            devices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.port;
                
                if (device.isXL2) {
                    option.textContent = `‚úÖ ${device.port} - ${device.deviceInfo}`;
                    option.style.backgroundColor = '#d4edda';
                    option.style.fontWeight = 'bold';
                } else {
                    option.textContent = `‚ùå ${device.port} - ${device.deviceInfo}`;
                    option.style.color = '#6c757d';
                    option.disabled = true;
                }
                
                deviceSelect.appendChild(option);
            });
            
            // Auto-select first XL2 device if found
            const firstXL2 = devices.find(d => d.isXL2);
            if (firstXL2) {
                deviceSelect.value = firstXL2.port;
                addConsoleMessage(`Auto-selected XL2 device: ${firstXL2.deviceInfo}`, 'success');
            }
        }

        function updateScanStatus(message, type = 'info') {
            const scanStatus = document.getElementById('scanStatus');
            scanStatus.textContent = message;
            scanStatus.className = type;
        }

        function updateMeasurementDisplay(measurement) {
            // Always show 12.5 Hz as the frequency we're monitoring
            document.getElementById('frequencyValue').textContent = '12.5';
            
            if (measurement.type === 'fft_spectrum') {
                // FFT spectrum data - show 12.5Hz dB value
                document.getElementById('dbValue').textContent = 
                    measurement.hz12_5_dB !== null ? measurement.hz12_5_dB.toFixed(2) : '--';
            } else {
                // Single measurement data
                document.getElementById('dbValue').textContent = 
                    measurement.dB ? measurement.dB.toFixed(2) : '--';
            }

            // Highlight if this is 12.5Hz
            const display = document.getElementById('measurementDisplay');
            if (measurement.is12_5Hz) {
                display.classList.add('hz-12-5-highlight');
                setTimeout(() => display.classList.remove('hz-12-5-highlight'), 2000);
            }
        }

        function update12_5HzDisplay(measurement) {
            const valueElement = document.getElementById('hz12_5Value');
            const timestampElement = document.getElementById('hz12_5Timestamp');
            
            let dbValue = null;
            
            // Extract dB value based on measurement type
            if (measurement.type === 'fft_spectrum' && measurement.hz12_5_dB !== null) {
                dbValue = measurement.hz12_5_dB;
            } else if (measurement.dB !== null && measurement.dB !== undefined) {
                dbValue = measurement.dB;
            }
            
            if (dbValue !== null) {
                valueElement.textContent = `${dbValue.toFixed(2)} dB`;
                timestampElement.textContent = new Date(measurement.timestamp).toLocaleTimeString();
                
                // Add pulse animation
                valueElement.classList.add('pulse');
                setTimeout(() => valueElement.classList.remove('pulse'), 1000);
                
                // Add to history
                hz12_5History.push({
                    dB: dbValue,
                    timestamp: measurement.timestamp
                });
                
                // Keep only last 10 measurements
                if (hz12_5History.length > 10) {
                    hz12_5History = hz12_5History.slice(-10);
                }
                
                // Update history display
                const historyElement = document.getElementById('hz12_5History');
                historyElement.innerHTML = '';
                hz12_5History.forEach((item, index) => {
                    const div = document.createElement('div');
                    div.className = 'hz-12-5-history-item';
                    div.innerHTML = `
                        <div>${item.dB.toFixed(2)} dB</div>
                        <div style="font-size: 0.8em; opacity: 0.8;">
                            ${new Date(item.timestamp).toLocaleTimeString()}
                        </div>
                    `;
                    historyElement.appendChild(div);
                });
            }
        }

        function addConsoleMessage(text, type = 'info', direction = '') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `console-message ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            messageDiv.innerHTML = `
                <span class="console-timestamp">${timestamp}</span>
                <span class="console-direction">${direction}</span>
                <span class="console-text">${text}</span>
            `;
            
            consoleElement.appendChild(messageDiv);
            consoleElement.scrollTop = consoleElement.scrollHeight;
            
            // Limit console messages
            while (consoleElement.children.length > 100) {
                consoleElement.removeChild(consoleElement.firstChild);
            }
        }

        function clearConsole() {
            consoleElement.innerHTML = '';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                sendCustomCommand();
            }
        });

        // Initialize FFT canvas
        function initFFTCanvas() {
            console.log('üé® Initializing FFT Canvas...');
            fftCanvas = document.getElementById('fftCanvas');
            if (!fftCanvas) {
                console.error('‚ùå FFT Canvas element not found!');
                return;
            }
            
            fftCtx = fftCanvas.getContext('2d');
            if (!fftCtx) {
                console.error('‚ùå Failed to get 2D context from canvas!');
                return;
            }
            
            // Set canvas size
            fftCanvas.width = 800;
            fftCanvas.height = 300;
            
            console.log('‚úÖ FFT Canvas initialized:', {
                width: fftCanvas.width,
                height: fftCanvas.height,
                hasContext: !!fftCtx
            });
            
            // Clear canvas with initial message
            fftCtx.fillStyle = '#000';
            fftCtx.fillRect(0, 0, fftCanvas.width, fftCanvas.height);
            
            // Draw "Waiting for data" message
            fftCtx.fillStyle = '#fff';
            fftCtx.font = '16px Arial';
            fftCtx.textAlign = 'center';
            fftCtx.fillText('Waiting for FFT data...', fftCanvas.width / 2, fftCanvas.height / 2);
            fftCtx.textAlign = 'left'; // Reset alignment
        }

        function drawFFTSpectrum(spectrum, frequencies, hz12_5_index) {
            console.log('üé® drawFFTSpectrum called:', {
                hasCtx: !!fftCtx,
                hasCanvas: !!fftCanvas,
                hasSpectrum: !!spectrum,
                spectrumLength: spectrum ? spectrum.length : 0,
                hasFrequencies: !!frequencies,
                hz12_5_index: hz12_5_index,
                spectrumSample: spectrum ? spectrum.slice(0, 3) : null
            });
            
            // Initialize canvas if not done yet
            if (!fftCanvas || !fftCtx) {
                console.warn('üîß Canvas not initialized, initializing now...');
                initFFTCanvas();
                if (!fftCanvas || !fftCtx) {
                    console.error('‚ùå Failed to initialize canvas');
                    return;
                }
            }
            
            if (!spectrum || spectrum.length === 0) {
                console.warn('‚ùå Cannot draw spectrum - no spectrum data');
                return;
            }
            
            try {
            
            const width = fftCanvas.width;
            const height = fftCanvas.height;
            const margin = 40;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;
            
            // Clear canvas
            fftCtx.fillStyle = '#000';
            fftCtx.fillRect(0, 0, width, height);
            
            // Find min/max for scaling
            const minDb = Math.min(...spectrum);
            const maxDb = Math.max(...spectrum);
            const dbRange = maxDb - minDb || 1;
            
            // Draw grid
            fftCtx.strokeStyle = '#333';
            fftCtx.lineWidth = 1;
            
            // Vertical grid lines (frequency)
            for (let i = 0; i <= 10; i++) {
                const x = margin + (i / 10) * plotWidth;
                fftCtx.beginPath();
                fftCtx.moveTo(x, margin);
                fftCtx.lineTo(x, height - margin);
                fftCtx.stroke();
            }
            
            // Horizontal grid lines (dB)
            for (let i = 0; i <= 10; i++) {
                const y = margin + (i / 10) * plotHeight;
                fftCtx.beginPath();
                fftCtx.moveTo(margin, y);
                fftCtx.lineTo(width - margin, y);
                fftCtx.stroke();
            }
            
            // Draw spectrum as bars
            const barWidth = plotWidth / spectrum.length;
            fftCtx.fillStyle = '#00ff00';
            
            for (let i = 0; i < spectrum.length; i++) {
                const x = margin + (i / spectrum.length) * plotWidth;
                const normalizedDb = Math.max(0, (spectrum[i] - minDb) / dbRange); // Ensure positive
                const barHeight = normalizedDb * plotHeight;
                const y = height - margin - barHeight;
                
                // Draw bar
                fftCtx.fillRect(x, y, barWidth * 0.8, barHeight); // 0.8 for small gap between bars
                
                // Add subtle border for better visibility
                fftCtx.strokeStyle = '#008800';
                fftCtx.lineWidth = 0.5;
                fftCtx.strokeRect(x, y, barWidth * 0.8, barHeight);
            }
            
            // Highlight 12.5Hz bin (should be first bin with FSTART 12.5)
            if (hz12_5_index >= 0 && hz12_5_index < spectrum.length) {
                const x = margin + (hz12_5_index / spectrum.length) * plotWidth;
                const normalizedDb = Math.max(0, (spectrum[hz12_5_index] - minDb) / dbRange);
                const barHeight = normalizedDb * plotHeight;
                const y = height - margin - barHeight;
                
                // Highlight the 12.5Hz bar with red color
                fftCtx.fillStyle = '#ff6b6b';
                fftCtx.fillRect(x, y, barWidth * 0.8, barHeight);
                
                // Add thicker border for 12.5Hz bar
                fftCtx.strokeStyle = '#ff0000';
                fftCtx.lineWidth = hz12_5_index === 0 ? 3 : 2;
                fftCtx.strokeRect(x, y, barWidth * 0.8, barHeight);
                
                // Draw vertical line across entire plot
                fftCtx.strokeStyle = '#ff6b6b';
                fftCtx.lineWidth = hz12_5_index === 0 ? 3 : 2;
                fftCtx.setLineDash([5, 5]); // Dashed line
                fftCtx.beginPath();
                fftCtx.moveTo(x + barWidth * 0.4, margin);
                fftCtx.lineTo(x + barWidth * 0.4, height - margin);
                fftCtx.stroke();
                fftCtx.setLineDash([]); // Reset to solid line
                
                // Label with exact frequency
                fftCtx.fillStyle = '#ff6b6b';
                fftCtx.font = hz12_5_index === 0 ? 'bold 14px Arial' : '12px Arial';
                const label = hz12_5_index === 0 ? '12.5Hz (Bin 0)' : `12.5Hz (Bin ${hz12_5_index})`;
                fftCtx.fillText(label, x + barWidth + 5, margin + 20);
            }
            
            // Draw axes labels
            fftCtx.fillStyle = '#fff';
            fftCtx.font = '12px Arial';
            
            // Frequency labels
            if (frequencies && frequencies.length > 0) {
                const minFreq = frequencies[0];
                const maxFreq = frequencies[frequencies.length - 1];
                fftCtx.fillText(`${minFreq} Hz`, margin, height - 10);
                fftCtx.fillText(`${maxFreq} Hz`, width - margin - 40, height - 10);
            } else {
                // Fallback labels when frequencies are not available
                fftCtx.fillText(`12.5 Hz`, margin, height - 10);
                fftCtx.fillText(`64.5 Hz`, width - margin - 40, height - 10);
            }
            
            // dB labels
            fftCtx.fillText(`${maxDb.toFixed(1)} dB`, 5, margin + 5);
            fftCtx.fillText(`${minDb.toFixed(1)} dB`, 5, height - margin + 15);
            
            // Update status
            document.getElementById('fftStatus').textContent = `Live FFT - ${spectrum.length} bins - Updated: ${new Date().toLocaleTimeString()}`;
            document.getElementById('fftStatus').className = 'fft-status active';
            
            console.log('‚úÖ FFT Spectrum drawn successfully');
            
            } catch (error) {
                console.error('‚ùå Error drawing FFT spectrum:', error);
                // Update status to show error
                document.getElementById('fftStatus').textContent = `Error drawing spectrum: ${error.message}`;
                document.getElementById('fftStatus').className = 'fft-status';
            }
        }

        // Test function to draw sample spectrum
        function drawTestSpectrum() {
            if (!fftCtx) return;
            
            // Generate test data
            const testSpectrum = [];
            for (let i = 0; i < 143; i++) {
                testSpectrum.push(20 + Math.random() * 40); // Random values between 20-60 dB
            }
            
            drawFFTSpectrum(testSpectrum, null, 0);
            console.log('Test spectrum drawn');
        }
        
        // Force canvas test function
        function forceCanvasTest() {
            alert('Force canvas test button clicked!');
            console.log('üîß Force canvas test...');
            
            if (!fftCanvas) {
                console.log('üîß Canvas not found, initializing...');
                initFFTCanvas();
            }
            
            if (fftCtx) {
                // Clear canvas
                fftCtx.fillStyle = '#000';
                fftCtx.fillRect(0, 0, fftCanvas.width, fftCanvas.height);
                
                // Draw test shapes
                fftCtx.fillStyle = 'red';
                fftCtx.fillRect(50, 50, 100, 100);
                
                fftCtx.fillStyle = 'green';
                fftCtx.fillRect(200, 50, 100, 100);
                
                fftCtx.fillStyle = 'blue';
                fftCtx.fillRect(350, 50, 100, 100);
                
                fftCtx.fillStyle = 'white';
                fftCtx.font = '20px Arial';
                fftCtx.fillText('Canvas Test - Working!', 50, 200);
                
                console.log('‚úÖ Force canvas test completed');
                alert('Canvas test completed - check the canvas!');
            } else {
                console.error('‚ùå Canvas context still not available');
                alert('Canvas context not available!');
            }
        }

        // Auto-scan for devices on page load
        window.addEventListener('load', () => {
            console.log('üöÄ Page loaded, initializing...');
            
            // Initialize DOM elements
            connectionStatus = document.getElementById('connectionStatus');
            connectionText = document.getElementById('connectionText');
            deviceInfo = document.getElementById('deviceInfo');
            consoleElement = document.getElementById('console');
            portSelect = document.getElementById('portSelect');
            connectBtn = document.getElementById('connectBtn');
            disconnectBtn = document.getElementById('disconnectBtn');
            continuousBtn = document.getElementById('continuousBtn');
            stopBtn = document.getElementById('stopBtn');
            
            console.log('‚úÖ DOM elements initialized');
            
            try {
                initFFTCanvas();
                console.log('‚úÖ FFT Canvas initialization completed');
            } catch (error) {
                console.error('‚ùå Error initializing FFT Canvas:', error);
            }
            
            
            // Draw test spectrum after 2 seconds to verify canvas works
            setTimeout(() => {
                console.log('üß™ Drawing test spectrum...');
                try {
                    drawTestSpectrum();
                } catch (error) {
                    console.error('‚ùå Error drawing test spectrum:', error);
                }
            }, 2000);
            
            // DISABLED: Don't auto-scan for devices on page load
            // setTimeout(() => {
            //     console.log('üîç Auto-scanning for devices...');
            //     try {
            //         scanForDevices();
            //     } catch (error) {
            //         console.error('‚ùå Error scanning for devices:', error);
            //     }
            // }, 1000);
        });

        // Custom command input enter key
        document.getElementById('customCommand').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendCustomCommand();
            }
        });

        // GPS Map Functions
        function initializeGPSMap() {
            // Initialize the map centered on a default location (will be updated when GPS connects)
            gpsMap = L.map('gpsMap').setView([54.319, 9.705], 15);
            
            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(gpsMap);
            
            // Initialize track line
            gpsTrackLine = L.polyline([], {
                color: 'red',
                weight: 3,
                opacity: 0.8
            }).addTo(gpsMap);
            
            console.log('GPS Map initialized');
        }

        function updateGPSMap(location) {
            if (!gpsMap) return;
            
            const lat = location.latitude;
            const lon = location.longitude;
            
            // Update or create GPS marker
            if (gpsMarker) {
                gpsMarker.setLatLng([lat, lon]);
            } else {
                gpsMarker = L.marker([lat, lon], {
                    icon: L.divIcon({
                        className: 'gps-marker',
                        html: 'üìç',
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    })
                }).addTo(gpsMap);
                
                // Center map on first GPS position
                gpsMap.setView([lat, lon], 16);
            }
            
            // Add to track if tracking is enabled
            if (isTracking) {
                const newPoint = [lat, lon];
                gpsTrack.push(newPoint);
                gpsTrackLine.addLatLng(newPoint);
                
                // Calculate distance if we have a previous point
                if (lastGPSPosition) {
                    const distance = calculateDistance(
                        lastGPSPosition.latitude, lastGPSPosition.longitude,
                        lat, lon
                    );
                    totalDistance += distance;
                    document.getElementById('trackDistance').textContent = totalDistance.toFixed(1);
                }
                
                // Update track points count
                document.getElementById('trackPoints').textContent = gpsTrack.length;
            }
            
            // Update speed display
            if (location.speed !== undefined) {
                const speedKmh = (location.speed || 0) * 1.852; // Convert knots to km/h
                document.getElementById('currentSpeed').textContent = speedKmh.toFixed(1);
                
                if (speedKmh > maxSpeed) {
                    maxSpeed = speedKmh;
                    document.getElementById('maxSpeed').textContent = maxSpeed.toFixed(1);
                }
            }
            
            lastGPSPosition = location;
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            // Haversine formula to calculate distance between two GPS points
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in meters
        }

        function centerMapOnGPS() {
            if (gpsMarker && gpsMap) {
                gpsMap.setView(gpsMarker.getLatLng(), 16);
            }
        }

        function clearTrack() {
            gpsTrack = [];
            gpsTrackLine.setLatLngs([]);
            totalDistance = 0;
            maxSpeed = 0;
            
            // Reset statistics
            document.getElementById('trackDistance').textContent = '0.0';
            document.getElementById('trackPoints').textContent = '0';
            document.getElementById('maxSpeed').textContent = '0.0';
            
            addConsoleMessage('GPS track cleared', 'info');
        }

        function toggleTracking() {
            const trackingBtn = document.getElementById('trackingBtn');
            
            isTracking = !isTracking;
            
            if (isTracking) {
                trackingBtn.textContent = '‚è∏Ô∏è Stop Tracking';
                trackingBtn.className = 'btn btn-danger';
                addConsoleMessage('GPS tracking started', 'success');
            } else {
                trackingBtn.textContent = '‚ñ∂Ô∏è Start Tracking';
                trackingBtn.className = 'btn btn-success';
                addConsoleMessage('GPS tracking stopped', 'info');
            }
        }

        // Heatmap Functions
        function initializeHeatmap() {
            console.log('üî• Initializing heatmap...');
            console.log('üî• GPS map available:', !!gpsMap);
            
            if (!gpsMap) {
                console.error('üî• Cannot initialize heatmap - GPS map not available');
                return;
            }
            
            // Check if heatmap plugin is available
            if (typeof L.heatLayer !== 'function') {
                console.error('üî• L.heatLayer is not available. Heatmap plugin not loaded?');
                addConsoleMessage('‚ùå Heatmap plugin not loaded', 'error');
                return;
            }
            
            try {
                // Initialize heatmap layer
                heatmapLayer = L.heatLayer([], {
                    radius: 25,
                    blur: 15,
                    maxZoom: 17,
                    gradient: {
                        0.0: 'blue',    // Low dB values
                        0.25: 'cyan',
                        0.5: 'lime',
                        0.75: 'yellow',
                        1.0: 'red'      // High dB values
                    }
                });
                
                console.log('üî• Heatmap layer initialized successfully:', !!heatmapLayer);
                console.log('üî• Heatmap layer type:', typeof heatmapLayer);
            } catch (error) {
                console.error('üî• Error initializing heatmap layer:', error);
                addConsoleMessage('‚ùå Error initializing heatmap: ' + error.message, 'error');
            }
        }

        function recalculateHeatmapData() {
            console.log('üî• Recalculating heatmap data...');
            
            // Recalculate all heatmap intensities based on current min/max
            heatmapData = [];
            
            dbMeasurements.forEach(measurement => {
                let intensity = 0.5; // Default intensity
                if (maxDb !== minDb && maxDb !== null && minDb !== null) {
                    intensity = (measurement.db - minDb) / (maxDb - minDb);
                }
                heatmapData.push([measurement.lat, measurement.lon, intensity]);
            });
            
            // Update heatmap if visible and properly attached to map
            if (isHeatmapVisible && heatmapLayer && gpsMap && gpsMap.hasLayer(heatmapLayer)) {
                try {
                    heatmapLayer.setLatLngs(heatmapData);
                    console.log('üî• Heatmap data updated successfully');
                } catch (error) {
                    console.error('üî• Error updating heatmap data:', error);
                    addConsoleMessage('‚ùå Error updating heatmap, reinitializing...', 'warning');
                    // Reinitialize the heatmap
                    gpsMap.removeLayer(heatmapLayer);
                    heatmapLayer = null;
                    initializeHeatmap();
                    if (heatmapLayer) {
                        gpsMap.addLayer(heatmapLayer);
                        heatmapLayer.setLatLngs(heatmapData);
                    }
                }
            }
            
            // Update UI
            updateHeatmapStats();
            
            console.log(`üî• Recalculated heatmap with ${heatmapData.length} points, range: ${minDb?.toFixed(1)} - ${maxDb?.toFixed(1)} dB`);
        }

        function addDbMeasurement(lat, lon, dbValue) {
            if (!lat || !lon || dbValue === null || dbValue === undefined) return;
            
            // Store the measurement
            const measurement = {
                lat: lat,
                lon: lon,
                db: dbValue,
                timestamp: new Date()
            };
            
            dbMeasurements.push(measurement);
            
            // Update min/max dB values
            const oldMinDb = minDb;
            const oldMaxDb = maxDb;
            
            if (minDb === null || dbValue < minDb) minDb = dbValue;
            if (maxDb === null || dbValue > maxDb) maxDb = dbValue;
            
            // If min/max changed, recalculate all intensities
            if (oldMinDb !== minDb || oldMaxDb !== maxDb) {
                recalculateHeatmapData();
            } else {
                // Just add the new point with correct intensity
                let intensity = 0.5; // Default intensity
                if (maxDb !== minDb && maxDb !== null && minDb !== null) {
                    intensity = (dbValue - minDb) / (maxDb - minDb);
                }
                
                heatmapData.push([lat, lon, intensity]);
                
                // Update heatmap if visible and properly attached to map
                if (isHeatmapVisible && heatmapLayer && gpsMap && gpsMap.hasLayer(heatmapLayer)) {
                    try {
                        heatmapLayer.setLatLngs(heatmapData);
                    } catch (error) {
                        console.error('üî• Error adding point to heatmap:', error);
                        // Try to re-initialize the heatmap
                        isHeatmapVisible = false;
                        initializeHeatmap();
                        if (heatmapLayer) {
                            gpsMap.addLayer(heatmapLayer);
                            heatmapLayer.setLatLngs(heatmapData);
                            isHeatmapVisible = true;
                        }
                    }
                }
            }
            
            // Update UI
            updateHeatmapStats();
            
            console.log(`üìç Added dB measurement: ${dbValue} dB at ${lat.toFixed(6)}, ${lon.toFixed(6)}`);
        }

        function updateHeatmapStats() {
            const pointsElement = document.getElementById('heatmapPoints');
            if (pointsElement) {
                pointsElement.textContent = dbMeasurements.length;
            }
            
            const rangeElement = document.getElementById('heatmapRange');
            if (rangeElement && minDb !== null && maxDb !== null) {
                rangeElement.textContent = `Range: ${minDb.toFixed(1)} to ${maxDb.toFixed(1)} dB`;
            }
        }

        function updateTrackStats() {
            // Update track statistics in the UI
            const trackPointsElement = document.getElementById('trackPoints');
            if (trackPointsElement) {
                trackPointsElement.textContent = gpsTrack.length;
            }
            
            // Calculate total distance if we have track points
            if (gpsTrack.length > 1) {
                let distance = 0;
                for (let i = 1; i < gpsTrack.length; i++) {
                    const prev = gpsTrack[i - 1];
                    const curr = gpsTrack[i];
                    distance += calculateDistance(prev[0], prev[1], curr[0], curr[1]);
                }
                
                const distanceElement = document.getElementById('totalDistance');
                if (distanceElement) {
                    distanceElement.textContent = (distance / 1000).toFixed(2) + ' km';
                }
            }
            
            console.log(`üìä Track stats updated: ${gpsTrack.length} points`);
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            // Haversine formula to calculate distance between two points
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in meters
        }

        function toggleHeatmap() {
            console.log('üî• Toggle heatmap called, current state:', isHeatmapVisible);
            console.log('üî• Heatmap layer exists:', !!heatmapLayer);
            console.log('üî• GPS map exists:', !!gpsMap);
            console.log('üî• Heatmap data length:', heatmapData.length);
            
            const btn = document.getElementById('heatmapBtn');
            const checkbox = document.getElementById('heatmapToggle');
            
            console.log('üî• Button found:', !!btn);
            console.log('üî• Checkbox found:', !!checkbox);
            
            if (isHeatmapVisible) {
                // Hide heatmap
                console.log('üî• Hiding heatmap...');
                if (heatmapLayer && gpsMap && gpsMap.hasLayer(heatmapLayer)) {
                    gpsMap.removeLayer(heatmapLayer);
                    console.log('üî• Heatmap layer removed from map');
                } else {
                    console.log('üî• Heatmap layer not on map or missing components');
                }
                isHeatmapVisible = false;
                if (btn) {
                    btn.textContent = 'üî• Show Heatmap';
                    btn.className = 'btn btn-secondary';
                }
                if (checkbox) checkbox.checked = false;
                addConsoleMessage('üî• Heatmap hidden', 'info');
            } else {
                // Show heatmap
                console.log('üî• Showing heatmap...');
                
                if (!gpsMap) {
                    addConsoleMessage('‚ùå GPS map not initialized', 'error');
                    return;
                }
                
                if (heatmapData.length === 0) {
                    addConsoleMessage('‚ö†Ô∏è No heatmap data available. Load CSV data or start measurements.', 'warning');
                    return;
                }
                
                if (!heatmapLayer) {
                    console.log('üî• Initializing heatmap layer...');
                    initializeHeatmap();
                }
                
                if (heatmapLayer) {
                    console.log('üî• Adding heatmap layer to map first...');
                    try {
                        // Add layer to map first, then set data
                        gpsMap.addLayer(heatmapLayer);
                        console.log('üî• Heatmap layer added to map, now setting data...');
                        heatmapLayer.setLatLngs(heatmapData);
                        
                        isHeatmapVisible = true;
                        if (btn) {
                            btn.textContent = 'üî• Hide Heatmap';
                            btn.className = 'btn btn-primary';
                        }
                        if (checkbox) checkbox.checked = true;
                        addConsoleMessage(`üî• Heatmap shown with ${heatmapData.length} data points`, 'success');
                        console.log('üî• Heatmap successfully displayed');
                    } catch (error) {
                        console.error('üî• Error showing heatmap:', error);
                        addConsoleMessage('‚ùå Error showing heatmap: ' + error.message, 'error');
                        // Clean up on error
                        if (gpsMap.hasLayer(heatmapLayer)) {
                            gpsMap.removeLayer(heatmapLayer);
                        }
                    }
                } else {
                    console.error('üî• Failed to create heatmap layer');
                    addConsoleMessage('‚ùå Failed to create heatmap layer', 'error');
                }
            }
        }

        function toggleHeatmapVisibility() {
            toggleHeatmap();
        }
        
        function testHeatmap() {
            console.log('üß™ Testing heatmap functionality...');
            
            // Clear existing data
            clearHeatmap();
            
            // Add some test data points around a central location
            const centerLat = 52.5200; // Berlin coordinates
            const centerLon = 13.4050;
            
            // Generate test measurements in a grid pattern
            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 5; j++) {
                    const lat = centerLat + (i - 2) * 0.001; // Small offset
                    const lon = centerLon + (j - 2) * 0.001;
                    const dbValue = 30 + Math.random() * 40; // Random dB between 30-70
                    
                    addDbMeasurement(lat, lon, dbValue);
                }
            }
            
            // Center map on test data
            if (gpsMap) {
                gpsMap.setView([centerLat, centerLon], 15);
            }
            
            addConsoleMessage(`üß™ Added ${dbMeasurements.length} test measurements`, 'info');
            addConsoleMessage('üß™ Try toggling the heatmap now', 'info');
        }

        function clearHeatmap() {
            console.log('üî• Clearing heatmap data...');
            
            // Clear all heatmap data
            heatmapData = [];
            dbMeasurements = [];
            minDb = null;
            maxDb = null;
            
            // Remove heatmap layer from map if it exists
            if (heatmapLayer && gpsMap && gpsMap.hasLayer(heatmapLayer)) {
                console.log('üî• Removing heatmap layer from map...');
                gpsMap.removeLayer(heatmapLayer);
            }
            
            // Don't try to reset the layer data if it's not on the map
            // Just set the layer to null and let it be recreated when needed
            heatmapLayer = null;
            
            // Update UI
            updateHeatmapStats();
            const rangeElement = document.getElementById('heatmapRange');
            if (rangeElement) {
                rangeElement.textContent = 'Range: -- to -- dB';
            }
            
            // Reset button state
            isHeatmapVisible = false;
            const btn = document.getElementById('heatmapBtn');
            const checkbox = document.getElementById('heatmapToggle');
            
            if (btn) {
                btn.textContent = 'üî• Show Heatmap';
                btn.className = 'btn btn-secondary';
            }
            if (checkbox) {
                checkbox.checked = false;
            }
            
            addConsoleMessage('üî• dB heatmap data cleared', 'info');
        }

        // Load CSV data and display on map
        async function loadCSVData() {
            try {
                addConsoleMessage('üìä Loading CSV data...', 'info');
                
                const response = await fetch('/api/csv-data');
                const result = await response.json();
                
                if (!result.success) {
                    addConsoleMessage(`‚ùå Failed to load CSV: ${result.message}`, 'error');
                    return;
                }
                
                const csvData = result.data;
                addConsoleMessage(`üìä Loaded ${csvData.length} measurements from CSV`, 'success');
                
                // Debug: Show first few data points
                console.log('üìä CSV data sample:', csvData.slice(0, 3));
                if (csvData.length > 0) {
                    console.log('üìä First point structure:', Object.keys(csvData[0]));
                    console.log('üìä First point values:', csvData[0]);
                }
                
                // Clear existing data
                clearHeatmap();
                clearTrack();
                
                // Process CSV data
                let csvHeatmapData = [];
                let csvTrackPoints = [];
                let csvMinDb = null;
                let csvMaxDb = null;
                let validPointsCount = 0;
                let skippedPointsCount = 0;
                
                // Detect CSV format - check if it's array-based or object-based
                let isArrayFormat = false;
                let latIndex = 3; // Default indices for array format
                let lonIndex = 4;
                let dbIndex = 2;
                let latField = 'latitude';
                let lonField = 'longitude';
                let dbField = 'db';
                
                if (csvData.length > 0) {
                    const firstRow = csvData[0];
                    
                    // Check if it's an array (numeric indices) or object (named fields)
                    if (Array.isArray(firstRow)) {
                        isArrayFormat = true;
                        console.log('üìä CSV format: Array-based');
                        console.log('üìä Sample row:', firstRow.slice(0, 8));
                        console.log('üìä Using indices: dB=2, lat=3, lon=4');
                    } else {
                        isArrayFormat = false;
                        const fields = Object.keys(firstRow);
                        console.log('üìä CSV format: Object-based');
                        console.log('üìä Available fields:', fields);
                        
                        // Try to find latitude field
                        latField = fields.find(f => 
                            f.toLowerCase().includes('lat') || 
                            f.toLowerCase().includes('breite')
                        ) || latField;
                        
                        // Try to find longitude field
                        lonField = fields.find(f => 
                            f.toLowerCase().includes('lon') || 
                            f.toLowerCase().includes('lng') ||
                            f.toLowerCase().includes('l√§nge')
                        ) || lonField;
                        
                        // Try to find dB field
                        dbField = fields.find(f => 
                            f.toLowerCase().includes('db') || 
                            f.toLowerCase().includes('12') ||
                            f.toLowerCase().includes('hz')
                        ) || dbField;
                        
                        console.log(`üìä Using fields: lat=${latField}, lon=${lonField}, db=${dbField}`);
                    }
                }

                csvData.forEach(point => {
                    // Extract values based on format
                    let lat, lon, db;
                    
                    if (isArrayFormat) {
                        lat = parseFloat(point[latIndex]);
                        lon = parseFloat(point[lonIndex]);
                        db = parseFloat(point[dbIndex]);
                    } else {
                        lat = parseFloat(point[latField]);
                        lon = parseFloat(point[lonField]);
                        db = parseFloat(point[dbField]);
                    }
                    
                    // Check if coordinates are valid numbers
                    if (isNaN(lat) || isNaN(lon) || isNaN(db)) {
                        console.warn('üî• Skipping invalid data point:', point);
                        skippedPointsCount++;
                        return; // Skip this point
                    }
                    
                    // Check if coordinates are in valid range
                    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                        console.warn('üî• Skipping out-of-range coordinates:', lat, lon);
                        skippedPointsCount++;
                        return; // Skip this point
                    }
                    
                    validPointsCount++;
                    
                    // Add to track
                    csvTrackPoints.push([lat, lon]);
                    
                    // Add to heatmap data
                    if (csvMinDb === null || db < csvMinDb) csvMinDb = db;
                    if (csvMaxDb === null || db > csvMaxDb) csvMaxDb = db;
                    
                    // Create timestamp
                    let timestamp;
                    if (isArrayFormat) {
                        // For array format: date is index 0, time is index 1
                        const dateStr = point[0];
                        const timeStr = point[1];
                        timestamp = new Date(`${dateStr} ${timeStr}`);
                    } else {
                        // For object format
                        timestamp = new Date(`${point.datum} ${point.uhrzeit}`);
                    }
                    
                    // Store measurement
                    dbMeasurements.push({
                        lat: lat,
                        lon: lon,
                        db: db,
                        timestamp: timestamp
                    });
                });
                
                // Update global min/max
                minDb = csvMinDb;
                maxDb = csvMaxDb;
                
                // Log processing summary
                console.log(`üìä Processed ${validPointsCount} valid points, skipped ${skippedPointsCount} invalid points`);
                if (skippedPointsCount > 0) {
                    addConsoleMessage(`‚ö†Ô∏è Skipped ${skippedPointsCount} invalid data points`, 'warning');
                }
                
                // Create normalized heatmap data from stored measurements
                dbMeasurements.forEach(measurement => {
                    let intensity = 0.5; // Default intensity
                    if (csvMaxDb !== csvMinDb && csvMaxDb !== null && csvMinDb !== null) {
                        intensity = (measurement.db - csvMinDb) / (csvMaxDb - csvMinDb);
                    }
                    csvHeatmapData.push([measurement.lat, measurement.lon, intensity]);
                });
                
                heatmapData = csvHeatmapData;
                
                // Draw track on map
                if (csvTrackPoints.length > 0) {
                    console.log(`üó∫Ô∏è Creating track with ${csvTrackPoints.length} points`);
                    console.log('üó∫Ô∏è First few points:', csvTrackPoints.slice(0, 3));
                    
                    gpsTrack = csvTrackPoints;
                    
                    if (gpsTrackLine) {
                        gpsMap.removeLayer(gpsTrackLine);
                    }
                    
                    try {
                        gpsTrackLine = L.polyline(csvTrackPoints, {
                            color: '#007bff',
                            weight: 3,
                            opacity: 0.8
                        }).addTo(gpsMap);
                        
                        console.log('üó∫Ô∏è Track line created successfully');
                    } catch (error) {
                        console.error('üó∫Ô∏è Error creating track line:', error);
                        addConsoleMessage('‚ùå Error creating GPS track line: ' + error.message, 'error');
                        return; // Don't continue if track creation failed
                    }
                    
                    // Fit map to track bounds
                    const bounds = L.latLngBounds(csvTrackPoints);
                    gpsMap.fitBounds(bounds, { padding: [20, 20] });
                    
                    // Add markers for start and end
                    const startPoint = csvTrackPoints[0];
                    const endPoint = csvTrackPoints[csvTrackPoints.length - 1];
                    
                    L.marker(startPoint, {
                        icon: L.divIcon({
                            className: 'db-measurement-marker',
                            html: 'üöÄ',
                            iconSize: [25, 25]
                        })
                    }).addTo(gpsMap).bindPopup('Start Point');
                    
                    L.marker(endPoint, {
                        icon: L.divIcon({
                            className: 'db-measurement-marker',
                            html: 'üèÅ',
                            iconSize: [25, 25]
                        })
                    }).addTo(gpsMap).bindPopup('End Point');
                }
                
                // Initialize and show heatmap automatically
                if (!heatmapLayer) {
                    console.log('üî• Initializing heatmap for CSV data...');
                    initializeHeatmap();
                }
                
                if (heatmapLayer && heatmapData.length > 0) {
                    try {
                        // Show heatmap automatically if not already visible
                        if (!isHeatmapVisible) {
                            gpsMap.addLayer(heatmapLayer);
                            isHeatmapVisible = true;
                            
                            // Update button state
                            const btn = document.getElementById('heatmapBtn');
                            const checkbox = document.getElementById('heatmapToggle');
                            if (btn) {
                                btn.textContent = 'üî• Hide Heatmap';
                                btn.className = 'btn btn-primary';
                            }
                            if (checkbox) {
                                checkbox.checked = true;
                            }
                        }
                        
                        // Set the data (layer should be on map now)
                        heatmapLayer.setLatLngs(heatmapData);
                    } catch (error) {
                        console.error('üî• Error setting CSV heatmap data:', error);
                        addConsoleMessage('‚ùå Error displaying heatmap: ' + error.message, 'error');
                    }
                }
                
                // Update UI
                updateHeatmapStats();
                updateTrackStats();
                
                addConsoleMessage(`üó∫Ô∏è Displayed ${csvData.length} points on map`, 'success');
                addConsoleMessage(`üìä dB Range: ${csvMinDb?.toFixed(1)} - ${csvMaxDb?.toFixed(1)} dB`, 'info');
                addConsoleMessage(`üî• Heatmap automatically enabled with ${heatmapData.length} data points`, 'success');
                
            } catch (error) {
                console.error('Error loading CSV data:', error);
                addConsoleMessage(`‚ùå Error loading CSV: ${error.message}`, 'error');
            }
        }

        // Initialize GPS map when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Wait a bit for the DOM to be fully ready
            setTimeout(() => {
                initializeGPSMap();
                initializeHeatmap();
                
                // Client connected - server will automatically send current status
                if (socket.connected) {
                    console.log('üîÑ Page loaded - waiting for server status update...');
                    // Server automatically sends current state to new clients
                    // No need to request it manually
                }
            }, 500);
        });
    </script>
    
    <!-- Include JavaScript modules -->
    <script src="js/utils.js"></script>
    <script src="js/config.js"></script>
    <script src="js/settings.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/console.js"></script>
    <script src="js/connection.js"></script>
    <script src="js/fft.js"></script>
    <script src="js/gps.js"></script>
    <script src="js/system-performance.js"></script>
    <script src="js/app.js"></script>
    
    <script>
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize the main application
            window.xl2App = new XL2Application();
        });
    </script>
</body>
</html>